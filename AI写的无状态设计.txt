FrostPage：关于无状态设计的一些思考


这个项目选择了一套看起来"过时"的技术栈：原生 JavaScript、JSON 文件存储、Hash 路由。没有框架，没有数据库，没有构建工具。
这不是为了炫技或标新立异，而是在实践一个被反复验证过的设计理念：无状态（Stateless）。


========================================
什么是无状态
========================================

无状态是一个经常被提到但很少被深入理解的概念。最简单的定义：一个系统如果不依赖历史信息就能完成当前操作，那它就是无状态的。
举两个例子：计算器的加法功能是无状态的。输入 2 + 3，无论何时何地，结果都是 5。它不需要知道上一次计算了什么。银行账户是有状态的。当前余额是所有历史交易的累积结果。没有这些历史记录，账户就无法运作。
用数学语言表达：
无状态：Output = f(Input)
有状态：Output = f(Input, History)
这个区别看似简单，却深刻影响着系统设计的方方面面。

========================================
无状态思想的历史
========================================

无状态设计不是新概念，它贯穿了计算机科学的 50 年历史。
1973 年，Unix 引入了管道（pipe）概念。Doug McIlroy 提出："程序应该像花园里的水管，可以自由连接组合。"一个典型的 Unix 命令行：
cat file.txt | grep "error" | sort | uniq -c | head -10
五个独立工具，通过管道串联，完成复杂任务。为什么能这样组合？因为每个工具都是无状态的：grep 不知道数据从哪来，sort 不关心会被谁用，head 只负责取前 10 行。正因为它们互不依赖，所以可以被任意组合。5 个工具理论上能产生 120 种不同的组合方式。
1977 年，John Backus 在图灵奖演讲中批判了命令式编程中的状态修改，提出函数式编程的理念。他认为状态变化是程序复杂性的根源。
2000 年，Roy Fielding 在博士论文中提出 REST 架构，将无状态作为核心约束。在分布式系统中，无状态是扩展性的基础。
2014 年，AWS Lambda 带来了 Serverless 理念：强制无状态的编程模型，但在实现层做优化。
每个计算时代都在重新发现同一个道理：简单胜过复杂，遗忘优于记忆。


========================================
为什么选择无状态
========================================

FrostPage 的技术选择基于无状态设计的几个核心优势。
可组合性：无状态组件就像乐高积木，可以自由组合。例如：
cat app.log | grep ERROR | grep -oE '[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+'
需求变化时，只需调整组合方式，不需要重写整个程序。
并行的自然性：无状态操作可以轻松并行。搜索 16 个文件，单线程需要 42 秒，16 线程并行只需 3.8 秒。10 倍性能提升，仅仅因为搜索工具是无状态的——没有共享状态，没有锁竞争，没有死锁风险。
生命周期的简单：有状态系统需要复杂的生命周期管理——启动时初始化连接池、加载配置、恢复状态、重建缓存；关闭时保存状态、等待请求完成、关闭连接、释放资源；崩溃后检查一致性、恢复事务、重建索引。无状态系统则简单得多：启动即可用，崩溃重启即恢复。没有状态恢复流程，没有清理工作。
可测试性：测试无状态函数就像测试数学公式——2 + 3 永远等于 5。相同输入永远产生相同输出。测试失败时，你知道是逻辑错误，而不是环境问题或时序问题。


========================================
技术选择的具体实践
========================================

原生 JavaScript：JavaScript 的原生 API 20 年前能跑的代码，今天依然能跑。框架会过时，但语言本身是稳定的。更重要的是，它避免了现代前端工程的复杂性：没有 webpack 配置、没有 babel 转译、没有几百个依赖包。双击 index.html 就能在浏览器运行。
JSON 文件存储：对于绝大多数个人项目，一年不会有 1000 篇文章，一秒不会有 1000 个并发请求，不需要跨数据中心的分布式事务。既然如此，为什么需要数据库？JSON 文件提供零配置（没有数据库安装、连接池、ORM）、零维护（不需要备份策略、索引优化、查询调优）、版本控制（Git 就是最好的审计日志）。
Hash 路由：Hash 路由（/#/research/detail/123）看起来不够"现代"，但它提供了最简单的实现——零服务器配置（静态文件服务器直接能跑）、零部署问题（可以部署在任何地方）、零刷新问题（# 后的内容不会发送给服务器）。用一个 # 号，换来了实现的简单性。


========================================
什么时候需要状态
========================================

无状态不是银弹。有些场景，状态是必需的。判断标准很简单：如果系统崩溃重启，用户能接受从零开始吗？

编译器崩溃了？重新编译就行 → 无状态
游戏崩溃了？存档丢失不可接受 → 有状态
搜索崩溃了？重新搜索就行 → 无状态
购物车崩溃了？商品丢失很恼人 → 有状态

对于博客系统，答案是：可以接受从零开始。

现实系统很少是纯无状态或纯有状态，而是智慧地混合使用。最常见的模式是：无状态的计算层 + 有状态的存储层。应用服务器是无状态的，可以随意扩展；数据库是有状态的，负责持久化。FrostPage 也采用这种模式：无状态的 FastAPI 服务 + JSON 文件存储。


========================================
Claude Code 的启示
========================================

Claude Code 的技术选择提供了一个有趣的对照。在其他 AI 编程助手都采用向量索引实现语义搜索时，Claude Code 选择了 grep——这个诞生于 1973 年的命令行工具。Anthropic 团队测试了 RAG（向量索引）等多种方案后发现：grep 方式在性能上大幅超越了其他方案。
为什么？确定性（grep 的行为完全可预测，向量搜索失败时调试是噩梦）、隐私（grep 完全本地执行，从架构上杜绝了泄露可能）、简单（没有索引构建、没有缓存管理、没有后台进程）、组合（可以通过管道与任何工具组合）。这再次验证：在某些场景下，最"原始"的方案反而是最优的选择。


========================================
权衡与取舍
========================================

选择简单也意味着放弃一些东西：放弃了热重载（改代码需要手动刷新浏览器）、放弃了 JSX（HTML 字符串拼接不够优雅）、放弃了 TypeScript（没有编译时类型检查）、放弃了丰富的生态（很多轮子需要自己造）。
但得到了：代码永不过时（10 年后依然能运行）、完全的掌控（每一行代码都在掌控之中）、极致的简单（没有构建、配置、依赖）、真正的自由（随时可以修改和扩展）。
这是一个有意识的权衡。对于这个项目的目标——个人博客系统，简单性比功能丰富性更重要。


========================================
核心思想
========================================

FrostPage 不是在炫技，而是在实践一个设计理念：在正确的地方、以正确的方式管理必要的状态。无状态不是目的，而是手段——它帮助构建更简单、更可靠、更可扩展的系统。状态并不是坏的，无管理的状态才是问题的根源。最好的设计不是完全无状态，而是在正确的地方管理必要的状态。
50 年前，Unix 创造者们说："只做一件事，并把它做好。"50 年后，这个道理依然有效。简单的工具活得最久，"健忘"的设计最自由。
